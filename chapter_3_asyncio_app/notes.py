notes = """
TCP
    Протокол TCP (transmission control protocol – протокол управления пе-
    редачей) предназначен для передачи данных между приложениями по
    сети. При его проектировании на первое место ставилась надежность. Он
    проверяет ошибки, гарантирует доставку данных по порядку и в случае
    необходимости производит повторную передачу. Но надежность сопро-
    вождается высокими накладными расходами. Большая часть веба функ-
    ционирует на базе TCP. Противоположностью TCP является протокол
    передачи дейтаграмм UDP, менее надежный, но и характеризующийся
    гораздо меньшими накладными расходами, чем TCP, а потому более про-
    изводительный. В этой книге нас будут интересовать только TCP-сокеты.
    
socket
    С помощью socket мы можем создать сервер который слушает пользователей... Но,
    когда мы инициализируем класс socket ничего не будет, так-как во первых у 
    сервера нет адреса по которому он слушает(порт и хост) и надо вручную вызвать 
    методы bind(чтоб привязать/пинговать адрес) которому передаём адрес, чтобы прослушать 
    запросы клиентов вызываем listen а чтобы принять вызываем accept
    Обратите внимание, accept блокирует программу до тех пор пока не получит запрос, после
    вернёт нам кортеж который содержит объект подключения и адрес клиента. 
    Объект подключения – это еще один сокет, который можно использовать для 
    чтения данных от клиента и записи адресованных ему данных.
    Когда клиент подключится, мы получим клиентский сокет и адрес
    клиента, о чем не замедлим сообщить.
    Теперь возникает вопрос как к нему подключиться... Инструментов для этого немало, но мы
    будем использовать Telnet
Telnet 
    Программа telnet была разработана в 1969 году, название является
    сокращением от teletype network (телетайпная сеть). Telnet устанав-
    ливает TCP-подключение к серверу, расположенному на указанном
    хосте. Затем создается терминал, который можно использовать для
    отправки и приема данных, отображаемых на экране терминала.
    В Mac OS установить telnet можно с помощью программы Home-
    brew, набрав команду brew install telnet (для установки Homebrew
    зайдите на сайт https://brew.sh/). В дистрибутивах Linux нужно будет
    использовать системный менеджер пакетов (apt-get install telnet
    или что-то в этом роде). В Windows лучше всего использовать про-
    грамму PuTTy, которую можно скачать с сайта https://putty.org.
    ПРИМЕЧАНИЕ!!!
    В PuTTY нужно будет включить режим локаль-
    ного редактирования строки, чтобы примеры из этой книги
    работали. Для этого перейдите в раздел Terminal в левой части
    окна настроек PuTTy и установите переключатель Local line edit-
    ing в режим Force on
Чтение данных из сокета и запись данных в сокет
    Теперь, когда сервер, способный принимать запросы на подключе-
    ние, создан, посмотрим, как читать посылаемые ему данные. В классе
    socket имеется метод recv, который позволяет получать данные из
    сокета. Метод принимает целое число, показывающее, сколько бай-
    тов мы хотим прочитать. Это важно, потому что мы не можем про-
    читать из сокета сразу все данные, а должны сохранять их в буфере,
    пока не дойдем до конца.
    В данном случае концом считается пара символов: возврат карет-
    ки, перевод строки, или '\r\n'. Именно эта пара добавляется в конец
    строки, когда пользователь нажимает клавишу Enter в telnet. Чтобы
    продемонстрировать, как работает буферизация небольших сообще-
    ний, зададим размер буфера заведомо малым. В реальных приложе-
    ниях нужен буфер побольше, например на 1024 байта. Большой буфер
    позволит воспользоваться механизмом буферизации на уровне опера-
    ционной системы, это эффективнее, чем буферизация в приложении
    Сейчас это приложение(server.py) в каждый момент времени обслуживает
    только одного клиента, но подключиться к одному серверному сокету
    может несколько клиентов. Изменим код, разрешив одновременное
    подключение нескольких клиентов. Попутно продемонстрируем, что
    нормально поддержать несколько клиентов с помощью блокирую-
    щих сокетов не получается.

Разрешение нескольких подключений и опасности блокирования
    Подключимся с помощью telnet
    и введем сообщение. Затем можно подключиться из второго telnet-
    клиента и отправить другое сообщение. И тут же наткнемся на про-
    блему. Первый клиент работает и получает копии своих сообщений,
    как и положено, а вот второй не получает ничего. Связано это с тем,
    что по умолчанию сокеты блокирующие. Методы accept и recv бло-
    кируют выполнение программы, пока не получат данные. А значит,
    после того как первый клиент подключился, мы будем ждать, когда
    он отправит свое первое сообщение. А остальные клиенты в это вре-
    мя зависнут в ожидании следующей итерации цикла, которая не про-
    изойдет, пока не придут данные от первого клиента.
    Очевидно, что пользователям это не понравится; мы написали
    программу, которая не масштабируется на случай, когда клиентов
    больше одного. Эту проблему можно решить, переведя сокеты в не-
    блокирующий режим. Если сокет помечен как неблокирующий, его
    методы не будут блокировать выполнение программы в ожидании
    поступления данных.
Работа с неблокирующими сокетами
    Предыдущая версия эхо-сервера допускала подключение нескольких
    клиентов, но при наличии более одного подключения возникали про-
    блемы: один клиент может заставить всех остальных ждать, пока он
    отправит данные. Эту проблему можно решить, переведя сокеты в не-
    блокирующий режим. Тогда вызов любого метода, который мог бы
    блокировать выполнение, например recv, будет возвращать управле-
    ние немедленно. Если в сокете есть доступные для обработки данные,
    то они будут возвращены, как в случае блокирующего сокета. А если
    нет, то сокет сразу даст нам знать, что данные не готовы, и мы сможем
    перейти к выполнению другого кода
    По сути дела, создание неблокирующего сокета отличается от соз-
    дания блокирующего только вызовом метода setblocking с параметром False
    По умолчанию это значение равно True, т. е. сокет блоки-
    рующий. Теперь посмотрим, что произойдет в исходном приложении,
    если это сделать. Пропадет ли ошибка?
    При выполнении этой программы одно отличие обнаруживается
    немедленно – программа падает сразу после запуска! Возникает ис-
    ключение BlockingIOError, потому что к серверному сокету еще ни-
    кто не подключился, поэтому нет данных для обработки
    Так сокет несколько неожиданно говорит нам: «У меня нет данных,
    попробуйте вызвать меня еще раз позже». Не существует простого
    способа узнать, есть ли в сокете данные, поэтому возможное реше-
    ние – перехватить исключение, проигнорировать его и продолжать
    цикл, пока в сокете не появятся данные. При таком подходе мы будем
    постоянно проверять наличие новых подключений с максимальной
    скоростью. Это должно решить проблему, с которой столкнулся наш
    эхо-сервер с блокирующим сокетом.
    На каждой итерации бесконечного цикла ни один из вызовов ac-
    cept и recv не блокирует выполнение, и мы либо сразу же получаем
    исключение, которое игнорируем, либо данные, которые обрабаты-
    ваем. Итерации выполняются быстро, и поведение программы не за-
    висит от того, посылает кто-нибудь данные или нет. Так что проблема
    блокирующего сервера решена, и несколько клиентов могут подклю-
    чаться и отправлять данные одновременно.
    Описанный подход работает, но обходится дорого. Первый недо-
    статок – качество кода. Перехват исключений всякий раз, как не ока-
    зывается данных, приводит к многословному и чреватому ошибка-
    ми коду. Второй – потребление ресурсов. Запустив эту программу на
    ноутбуке, вы уже через несколько секунд услышите, что вентилятор
    начал работать громче. Это приложение постоянно потребляет поч-
    ти 100 % процессорного времени.
    Выше мы уже упоминали о системе уведомления о событиях в опе-
    рационной системе, которая может уведомить нас о том, что в сокете
    появились данные. Эта система опирается на аппаратные прерыва-
    ния и не подразумевает опроса в цикле while, как в показанной выше
    программе. В Python имеется библиотека для использования такой
    системы уведомления. В следующем разделе мы воспользуемся ей
    для решения проблемы потребления ресурсов. Попутно построим
    примитивный цикл событий, работающий только для сокетов.
    
Использование модуля selectors для построения цикла событий сокетов
    У операционной системы есть эффективные API, позволяющие на-
    блюдать за появлением данных в сокетах и за другими событиями.
    Конкретный API зависит от системы (kqueue, epoll, IOCP – самые из-
    вестные), но все системы уведомления работают по одному прин-
    ципу. Мы передаем системе список сокетов, за событиями которых
    хотим наблюдать, а она сообщает, когда в одном из них появляются
    данные.
    Поскольку все это реализовано на аппаратном уровне, процессор
    в мониторинге почти не участвует, так что потребление ресурсов не-
    велико. Эти системы уведомления и лежат в основе механизма кон-
    курентности в asyncio. Поняв, как они устроены, мы сможем лучше
    понять, как работает asyncio
    Система уведомления о событиях зависит от операционной систе-
    мы. Но модуль Python selectors абстрагирует эту зависимость, так
    что мы получаем правильное событие, в какой бы системе наш код
    ни работал. То есть код оказывается переносимым.
    Эта библиотека предоставляет абстрактный базовый класс Bas-
    eSelector, имеющий реализации для каждой системы уведомления.
    Кроме того, имеется класс DefaultSelector, который автоматически
    выбирает реализацию, подходящую для конкретной системы
    У класса BaseSelector есть несколько важных концепций. Первая из
    них – регистрация. Если мы хотим получать уведомления для какого-
    то сокета, то регистрируем его, сообщая, какие именно события нас
    интересуют, например чтение и запись. Наоборот, если сокет нас
    больше не интересует, то его регистрацию можно отменить.
    Вторая концепция – селекция. Функция select блокирует выпол-
    нение, пока не произойдет какое-то событие, после чего возвраща-
    ет список сокетов, готовых для обработки, а также событие, которое
    произошло с каждым сокетом. Поддерживается также тайм-аут – если
    в течение указанного времени ничего не произошло, то возвращается
    пустой список сокетов
    Имея такие строительные блоки, мы можем написать неблокирую-
    щий эхо-сервер, не нагружающий процессор. После создания сервер-
    ного сокета мы регистрируем его в селекторе по умолчанию, который
    будет прослушивать запросы на подключение от клиентов. Как только
    кто-то подключится к серверному сокету, мы зарегистрируем клиент-
    ский сокет, чтобы селектор наблюдал за отправленными в него дан-
    ными. Получив данные, мы отправим их назад клиенту. Кроме того,
    добавим тайм-аут, чтобы продемонстрировать возможность выпол-
    нять другой код, пока мы ждем наступления событий.
    Эта программа печатает сообщение «Событий нет, подожду еще!»
    примерно каждую секунду, пока не будет получено событие подклю-
    чения. После этого мы регистрируем сокет для прослушивания собы-
    тий чтения. Теперь, как только клиент отправит нам данные, селектор
    вернет событие готовности данных и мы сможем прочитать их с по-
    мощью функции socket.recv. Мы написали полнофункциональный
    эхо-сервер, поддерживающий нескольких клиентов. У него нет про-
    блем с блокированием, поскольку чтение или запись производятся
    только тогда, когда имеются данные. Он почти не потребляет про-
    цессорного времени, так как мы пользуемся эффективной системой
    уведомления о событиях, которая реализована внутри операционной
    системы
    То, что мы сделали, во многом напоминает действия, выполняемые
    циклом событий под капотом. В данном случае события – получение
    данных через сокет. Каждая итерация нашего цикла событий и цик-
    ла событий asyncio запускается либо событием сокета, либо срабаты-
    ванием таймера. В цикле событий asyncio в любом из этих случаев
    активируется ожидающая сопрограмма и выполняется до конца или
    до следующего предложения await. Если await встречается в сопро-
    грамме, где используется неблокирующий сокет, то она регистрирует
    этот сокет в системном селекторе и запоминает, что эта сопрограмма
    приостановлена в ожидании результата
    Мы выполняем готовые к работе сопрограммы до тех пор, пока
    они не будут приостановлены в предложении await, и сохраняем их
    в массиве paused. Мы также отслеживаем новые сокеты, за которыми
    нужно наблюдать, и регистрируем их в селекторе. Затем вычисляем
    тайм-аут, указываемый при вызове select. Вычисление тайм-аута не
    вполне тривиально, обычно при этом учитывается, что запланиро-
    вано для выполнения в конкретный момент времени или в течение
    конкретного интервала. Примером может служить asyncio.sleep. За-
    тем мы вызываем select и ждем возникновения события сокета или
    истечения тайм-аута. Как только произойдет то или другое, мы об-
    рабатываем события и преобразуем их в список сопрограмм, готовых
    к выполнению.
    Хотя построенный нами цикл событий пригоден только для собы-
    тий сокетов, он демонстрирует идею использования селектора для
    регистрации интересующих нас сокетов, когда программа пробуж-
    дается только при возникновении чего-то, что мы хотим обработать.
    Более глубоко мы рассмотрим эту тему, когда будем строить собствен-
    ный цикл событий в конце книги.
    Теперь мы понимаем большую часть механизма, приводящего
    в движение asyncio. Но если бы мы ограничились селекторами для
    написания приложений, то пришлось бы реализовывать собственный
    цикл событий для получения той же функциональности, которую дает
    asyncio. Чтобы разобраться в том, как сделать это с помощью asyncio,
    возьмем все сделанное и переведем это на язык async / await и уже
    реализованного для нас цикла событий.
    
Эхо-сервер средствами цикла событий asyncio
    Уровень select для большинства приложений является слишком низ-
    ким. Возможно, мы хотим выполнять свой код в фоновом режиме,
    пока программа ждет поступления данных в сокет, или запускать фо-
    новые задачи по расписанию. Попытавшись сделать это с помощью
    одних лишь селекторов, мы в итоге написали бы собственный цикл
    событий, в то время как asyncio предлагает уже готовый. Кроме того,
    сопрограммы и задачи предоставляют абстракции поверх селекто-
    ров, благодаря чему код становится проще писать и сопровождать,
    поскольку думать о селекторах вообще не нужно.
    Теперь, когда мы лучше понимаем, как устроен цикл событий
    в asyncio, еще раз переделаем наш эхо-сервер, используя сопрограм-
    мы и задачи. Мы по-прежнему будем работать с низкоуровневыми
    сокетами, но на этот раз для управления ими воспользуемся API asyn-
    cio, которые возвращают сопрограммы. И немного расширим функ-
    циональность, чтобы продемонстрировать несколько ключевых кон-
    цепций asyncio
"""
