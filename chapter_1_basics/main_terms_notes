#КОНКУРЕНТНОСТЬ
# ЗДЕСЬ ФИШКА В ПЕРЕКЛЮЧЕНИИ!(т.е. мы переключаемся между задачами)
#ПАРАЛЛЕЛИЗМ
#    ЗДЕСЬ ФИШКА В ОДНОВРЕМЕННОЙ РАБОТЕ!(т.е. обе задачи активны одновременно)

# Ввод-вывод выполняют такие устройства,
# как клавиатура, жесткий диск и, конечно же, сетевая карта. Такие
# операции ждут ввода от пользователя или получения содержимого
# от веб-API. В синхронном приложении мы будем ждать завершения
# операции и до тех пор ничего не сможем делать. Это ведет к пробле-
# мам с производительностью и отзывчивостью, поскольку в каждый
# момент времени может выполняться только одна длительная опера-
# ция, а она не дает приложению больше ничего делать.

#Конкурентность возможна, когда несколько задач может работать не-
#зависимо друг от друга. Конкурентность можно организовать, имея
#процессор всего с одним ядром, применив вытесняющую многозадач-
#ность (определяется в следующем разделе) для переключения между
#задачами.

#Вытесняющая и не вытесняющая(кооперативная) многозадачность
#Вытесняющая
#    В этой модели мы позволяем операционной системе решить, как переключаться
#    между выполняемыми задачами с помощью процедуры
#    квантования времени. Когда операционная система переключает за-
#    дачи, мы говорим, что имеет место вытеснение.
#    Как устроен этот механизм, зависит от операционной системы.
#    Обычно для этого используется либо несколько потоков, либо не-
#    сколько процессов.
#Кооперативная
#    В этой модели мы не полагаемся для переключения между задача-
#    ми на операционную систему, а явно определяем в коде приложения
#    точки, где можно уступить управление другой задаче. Исполняемые
#    задачи кооперируются, т. е. говорят приложению: «Я сейчас на время
#    приостановлюсь, а ты можешь пока выполнять другие задачи».

#Процесс
#    Процессом называется работающее приложение, которому выделена
#    область памяти, недоступная другим приложениям.

#Поток
#    это наименьшая единица выполнения, которая может управляться операционной системой
#    Потоки можно представлять себе как облегченные процессы. Кроме
#    того, это наименьшая единица выполнения, которая может управляться
#    операционной системой. У потоков нет своей памяти, они
#    пользуются памятью создавшего их процесса. Потоки ассоциирова-
#    ны с процессом, создавшим их. С каждым процессом всегда ассоци-
#    ирован по меньшей мере один поток, обычно называемый главным.
#    Процесс может создавать дополнительные потоки, которые обычно
#    называются рабочими или фоновыми. Эти потоки могут конкурентно
#    выполнять другую работу наряду с главным потоком. Потоки, как
#    и процессы, могут работать параллельно на многоядерном процес-
#    се, и операционная система может переключаться между ними с по-
#    мощью квантования времени. Обычное Python-приложение создает
#    процесс и главный поток, который отвечает за его выполнение.
#    Процессы могут порождать дополнительные потоки, разделяющие
#    память со своим процессом-родителем. Они могут конкурентно вы-
#    полнять другую работу, это называется многопоточностью.

#Многопоточность не единственный способ добиться конкурентности.
#Можно вместо потоков создать несколько конкурентных процессов,
#это называется многопроцессностью.

#Многопроцессорность
#    В таком случае родительский
#    процесс создает один или более дочерних процессов, которыми
#    управляет, а затем распределяет между ними работу.
#    В Python для этой цели имеется модуль multiprocessing. Его API
#    похож на API модуля threading. Сначала создается процесс, при этом
#    передается функция target. Затем вызывается метод start, чтобы на-
#    чать выполнение процесса, и в конце – метод join, чтобы дождаться
#    его завершения.
#    Многопоточность и многопроцессность могут показаться волшебной
#    палочкой, обеспечивающей конкурентность в Python. Однако
#    развернуться во всю мощь этим моделям мешает одна деталь реализации
#    Python – глобальная блокировка интерпретатора(GIL)

#GIL
#    GIL - тема, вызывающая споры в сообществе Python. Говоря кратко, GIL
#    не дает Python-процессу исполнять более одной команды байт-кода
#    в каждый момент времени. Это означает, что, даже если имеется несколько
#    потоков на многоядерной машине, интерпретатор сможет
#    в каждый момент исполнять только один поток, содержащий написанный на Python код.
#    В мире, где процессоры имеют несколько ядер,
#    это создает серьезную проблему для разработчиков на Python, желающих воспользоваться
#    многопоточностью для повышения производительности приложений.
#    WARNING!!!
#    Многопроцессные приложения могут конкурентно выполнять несколько команд байт-кода, потому что
#    у каждого Python-процесса своя собственная GIL.
#    Так для чего же нужна GIL? Ответ кроется в том, как CPython управляет памятью.
#    В CPython память управляется в основном с помощью
#    подсчета ссылок. То есть для каждого объекта Python, например целого
#    числа, словаря или списка, подсчитывается, сколько объектов в данный момент
#    используют его. Когда объект перестает быть нужным
#    кому-то, счетчик ссылок на него уменьшается, а когда кто-то новый
#    обращается к нему, счетчик ссылок увеличивается. Если счетчик ссылок обратился в нуль,
#    значит, на объект никто не ссылается, поэтому
#    его можно удалить из памяти.
#    CPython – это эталонная реализация Python, т. е. стандартная реализация
#    языка, которая используется как эталон правильного поведения. Существуют и другие реализации,
#    например Jython, работающая под управлением виртуальной машины Java,
#    или IronPython, предназначенная для .NET Framework.
#    Конфликт потоков возникает из-за того, что интерпретатор CPython не является потокобезопасным.
#    Это означает, что если два или более потоков модифицируют разделяемую переменную,
#    то ее конечное состояние может оказаться неожиданным, поскольку зависит
#    от порядка доступа к переменной со стороны потоков. Эта ситуация называется состоянием гонки.
#    Состояния гонки могут возникать, когда два потока одновременно обращаются к одному
#    объекту Python
