#КОНКУРЕНТНОСТЬ
#    Говоря, что две задачи выполняются конкурентно, мы имеем в виду,
#    что они работают в одно и то же время. Чтобы их испечь, нужно сначала разо-
#    греть духовку. Разогрев может занимать десятки минут – это зависит
#    от духовки и требуемой температуры, но нам необязательно ждать,
#    пока духовка нагреется, поскольку можно в это время заняться дру-
#    гими делами, например смешать муку с сахаром и вбить в тесто яйца.
#    Это можно делать, пока духовка звуковым сигналом не известит нас
#    о том, что нагрелась.
#    Мы также не хотим связывать себя ограничением – приступать ко
#    второму торту только после готовности первого. Ничто не мешает за-
#    месить тесто для одного торта, положить его в миксер и начать го-
#    товить вторую порцию, пока первая взбивается. В этой модели мы
#    переключаемся между разными задачами конкурентно. Такое пере-
#    ключение (делать что-то, пока духовка разогревается, переключаться
#    с одного торта на другой) – пример конкурентного поведения.
#    ЗДЕСЬ ФИШКА В ПЕРЕКЛЮЧЕНИИ!(т.е. мы переключаемся между задачами)
#ПАРАЛЛЕЛИЗМ
#    Хотя конкурентность подразумевает, что несколько задач выполняет-
#    ся одновременно, это еще не значит, что они работают параллельно.
#    Говоря о параллельной работе, мы имеем в виду, что две задачи или бо-
#    лее не просто чередуются, а выполняются строго в одно и то же время.
#    Возвращаясь к примеру с тортами, представьте, что мы призвали
#    на помощь второго пекаря. В этом случае мы можем трудиться над
#    первым тортом, а помощник будет заниматься вторым. Два человека,
#    готовящих тесто, работают параллельно, потому что одновременно
#    делают два разных дела
#    ЗДЕСЬ ФИШКА В ОДНОВРЕМЕННОЙ РАБОТЕ!(т.е. обе задачи активны одновременно)
#Конкурентность возможна, когда несколько задач может работать не-
#зависимо друг от друга. Конкурентность можно организовать, имея
#процессор всего с одним ядром, применив вытесняющую многозадач-
#ность (определяется в следующем разделе) для переключения между
#задачами. С другой стороны, параллелизм означает, что мы должны
#выполнять две задачи или более строго одновременно. На машине
#с одним ядром это невозможно, необходимо иметь процессор с не-
#сколькими ядрами.
#Параллелизм подразумевает конкурентность, но обратное верно
#не всегда. Многопоточное приложение, работающее на многоядерной
#машине, является и конкурентным, и параллельным.
#
#Вытесняющая и не вытесняющая(кооперативная) многозадачность
#Вытесняющая
#    В этой модели мы позволяем операционной системе решить, как переключаться 
#    между выполняемыми задачами с помощью процедуры
#    квантования времени. Когда операционная система переключает за-
#    дачи, мы говорим, что имеет место вытеснение.
#    Как устроен этот механизм, зависит от операционной системы.
#    Обычно для этого используется либо несколько потоков, либо не-
#    сколько процессов.
#Кооперативная
#    В этой модели мы не полагаемся для переключения между задача-
#    ми на операционную систему, а явно определяем в коде приложения
#    точки, где можно уступить управление другой задаче. Исполняемые
#    задачи кооперируются, т. е. говорят приложению: «Я сейчас на время
#    приостановлюсь, а ты можешь пока выполнять другие задачи».
#Преимущества кооперативной многозадачности
#    В asyncio для организации конкурентности используется кооператив-
#    ная многозадачность. Когда приложение доходит до точки, в которой
#    может подождать результата, мы явно помечаем это в коде. Поэто-
#    му другой код может работать, пока мы ждем получения результата,
#    вычисляемого в фоновом режиме. Как только вычисление результата
#    завершится, мы «просыпаемся» и возобновляем задачу. Это является
#    формой конкурентности, потому что несколько задач может работать
#    одновременно, но – и это очень важно – не параллельно, так как их
#    выполнение чередуется.
#Процесс
#    Процессом называется работающее приложение, которому выделена
#    область памяти, недоступная другим приложениям. Пример созда-
#    ния Python-процесса – запуск простого приложения «hello world» или
#    ввод слова python в командной строке для запуска цикла REPL (цикл
#    чтения–вычисления–печати).
#    На одной машине может работать несколько процессов. Если ма-
#    шина оснащена процессором с несколькими ядрами, то несколь-
#    ко процессов могут работать одновременно. Если процессор имеет
#    только одно ядро, то все равно можно выполнять несколько прило-
#    жений конкурентно, но уже с применением квантования времени.
#    При использовании квантования операционная система будет авто-
#    матически вытеснять работающий процесс по истечении некоторо-
#    го промежутка времени и передавать процессор другому процессу.
#    Алгоритмы, определяющие, в какой момент переключать процессы,
#    зависят от операционной системы.
#Поток
#    Потоки можно представлять себе как облегченные процессы. Кроме
#    того, это наименьшая единица выполнения, которая может управляться 
#    операционной системой. У потоков нет своей памяти, они
#    пользуются памятью создавшего их процесса. Потоки ассоциирова-
#    ны с процессом, создавшим их. С каждым процессом всегда ассоци-
#    ирован по меньшей мере один поток, обычно называемый главным.
#    Процесс может создавать дополнительные потоки, которые обычно
#    называются рабочими или фоновыми. Эти потоки могут конкурентно
#    выполнять другую работу наряду с главным потоком. Потоки, как
#    и процессы, могут работать параллельно на многоядерном процес-
#    се, и операционная система может переключаться между ними с по-
#    мощью квантования времени. Обычное Python-приложение создает
#    процесс и главный поток, который отвечает за его выполнение.
#    Процессы могут порождать дополнительные потоки, разделяющие
#    память со своим процессом-родителем. Они могут конкурентно вы-
#    полнять другую работу, это называется многопоточностью.
#    
#Многопоточность не единственный способ добиться конкурентности. 
#Можно вместо потоков создать несколько конкурентных процессов,
#это называется многопроцессностью.
#
#Многопроцессорность
#    В таком случае родительский 
#    процесс создает один или более дочерних процессов, которыми
#    управляет, а затем распределяет между ними работу.
#    В Python для этой цели имеется модуль multiprocessing. Его API
#    похож на API модуля threading. Сначала создается процесс, при этом
#    передается функция target. Затем вызывается метод start, чтобы на-
#    чать выполнение процесса, и в конце – метод join, чтобы дождаться
#    его завершения.
#    Многопоточность и многопроцессность могут показаться волшебной 
#    палочкой, обеспечивающей конкурентность в Python. Однако
#    развернуться во всю мощь этим моделям мешает одна деталь реализации 
#    Python – глобальная блокировка интерпретатора(GIL)
#    
#GIL
#    GIL - тема, вызывающая споры в сообществе Python. Говоря кратко, GIL
#    не дает Python-процессу исполнять более одной команды байт-кода
#    в каждый момент времени. Это означает, что, даже если имеется несколько 
#    потоков на многоядерной машине, интерпретатор сможет
#    в каждый момент исполнять только один поток, содержащий написанный на Python код.
#    В мире, где процессоры имеют несколько ядер,
#    это создает серьезную проблему для разработчиков на Python, желающих воспользоваться 
#    многопоточностью для повышения производительности приложений.
#    WARNING!!!
#    Многопроцессные приложения могут конкурентно выполнять несколько команд байт-кода, потому что
#    у каждого Python-процесса своя собственная GIL.
#    Так для чего же нужна GIL? Ответ кроется в том, как CPython управляет памятью. 
#    В CPython память управляется в основном с помощью
#    подсчета ссылок. То есть для каждого объекта Python, например целого
#    числа, словаря или списка, подсчитывается, сколько объектов в данный момент 
#    используют его. Когда объект перестает быть нужным
#    кому-то, счетчик ссылок на него уменьшается, а когда кто-то новый
#    обращается к нему, счетчик ссылок увеличивается. Если счетчик ссылок обратился в нуль, 
#    значит, на объект никто не ссылается, поэтому
#    его можно удалить из памяти.
#    CPython – это эталонная реализация Python, т. е. стандартная реализация
#    языка, которая используется как эталон правильного поведения. Существуют и другие реализации, 
#    например Jython, работающая под управлением виртуальной машины Java, 
#    или IronPython, предназначенная для .NET Framework.
#    Конфликт потоков возникает из-за того, что интерпретатор CPython не является потокобезопасным. 
#    Это означает, что если два или более потоков модифицируют разделяемую переменную, 
#    то ее конечное состояние может оказаться неожиданным, поскольку зависит 
#    от порядка доступа к переменной со стороны потоков. Эта ситуация называется состоянием гонки. 
#    Состояния гонки могут возникать, когда два потока одновременно обращаются к одному 
#    объекту Python
#    Многопоточная версия работала почти столько же времени. На
#    самом деле даже чуть дольше! Это все из-за GIL и накладных расходов 
#    на создание и управление потоками. Да, потоки выполняются
#    конкурентно, но в каждый момент времени только одному из них
#    разрешено выполнять Python-код. А второй поток вынужден ждать
#    завершения первого, что сводит на нет весь смысл нескольких потоков.
#    НО,
#    Глобальная блокировка интерпретатора освобождается на время
#    выполнения операций ввода-вывода. Это позволяет использовать по-
#    токи для конкурентного выполнения ввода-вывода, но не для выпол-
#    нения счетного кода, написанного на Python (есть исключения, когда
#    GIL все же освобождается на время выполнения счетных задач, и мы
#    обсудим их в следующей главе). т.е. с IO-bound задачами тоже можно юзать 
#    многопоточность
#    Так почему же GIL освобождается при вводе-выводе, но не освобождается 
#    для счетных задач? Все дело в системных вызовах, которые
#    выполняются за кулисами. В случае ввода-вывода низкоуровневые
#    системные вызовы работают за пределами среды выполнения Python.
#    Это позволяет освободить GIL, потому что код операционной системы 
#    не взаимодействует напрямую с объектами Python. GIL захватывается снова,
#    только когда полученные данные переносятся в объект
#    Python. Стало быть, на уровне ОС операции ввода-вывода выполняются конкурентно. 
#    Эта модель обеспечивает конкурентность, но не параллелизм.
#
#Asyncio и GIL
#    В asyncio используется тот факт, что операции ввода-вывода освобождают GIL,
#    что позволяет реализовать конкурентность даже в одном потоке. 
#    При работе с asyncio мы создаем объекты сопрограмм. Сопрограмму можно
#    представлять себе как облегченный поток. Точно так
#    же, как может быть несколько потоков, работающих одновременно
#    и исполняющих разные операции ввода-вывода, так может существовать 
#    много сопрограмм, работающих бок о бок. Ожидая завершения
#    сопрограмм, занимающихся вводом-выводом, мы можем выполнять
#    другой Python-код, получая таким образом конкурентность. Важно
#    отметить, что asyncio не обходит GIL, мы по-прежнему ограничены
#    ей. Если имеется счетная задача, то для ее конкурентного выполнения
#    все равно нужно заводить отдельный процесс (и в asyncio есть для
#    этого средства), иначе производительность снизится
#    
#Как работает однопоточная конкурентность
#    В предыдущем разделе мы рассмотрели многопоточность как ме-
#    ханизм конкурентного выполнения операций ввода-вывода. Одна-
#    ко для достижения такого вида конкурентности заводить несколько
#    потоков ни к чему. Все это можно сделать в рамках одного процес-
#    са и одного потока. При этом мы воспользуемся тем фактом, что на
#    уровне ОС операции ввода-вывода могут завершаться конкурентно.
#    Чтобы лучше понять, как это возможно, рассмотрим подробнее, как
#    работают сокеты и конкретно неблокирующие сокеты(Логично, зачем юзать 
#    несколько потоков когда можно всё это сделать в 1 потоке)
#    
#Сокет
#    Сокет – это низкоуровневая абстракция отправки и получения данных по сети. 
#    Именно с ее помощью производится обмен данными
#    между клиентами и серверами. Сокеты поддерживают две основные операции: 
#    отправку и получение байтов. Мы записываем байты
#    в сокет, затем они передаются по адресу назначения, чаще всего на
#    какой-то сервер. Отправив байты, мы ждем, пока сервер пришлет ответ 
#    в наш сокет. Когда байты окажутся в сокете, мы сможем прочитать результат
#    Если нужно получить содержимое страницы example.com, то мы открываем сокет,
#    подключенный к серверу example.com. Затем записываем в сокет запрос и ждем 
#    ответа от сервера, в данном случае HTML-кода веб-страницы.
#    По умолчанию сокеты блокирующие. Это значит, что на все время ожидания 
#    ответа от сервера приложение приостанавливается
#    или блокируется. Следовательно, оно не может ничего делать, пока
#    не придут данные от сервера или произойдет ошибка или случится
#    тайм-аут.
#    На уровне операционной системы эта блокировка ни к чему. Сокеты могут работать 
#    в неблокирующем режиме, когда мы просто начинаем операцию чтения или записи и забываем о ней,
#    а сами занимаемся другими делами. Но позже операционная система уведомляет
#    нас о том, что байты получены, и в этот момент мы можем уделить
#    им внимание. Это позволяет приложению не ждать прихода байтов,
#    а делать что-то полезное.
#    Для реализации такой схемы применяются
#    различные системы уведомления с помощью событий, разные в раз-
#    ных ОС. Библиотека asyncio абстрагирует различия между системами
#    уведомления, а именно:
#    1: kqueue – FreeBSD и MacOS;
#    2: epoll – Linux;
#    3: IOCP (порт завершения ввода-вывода) – Windows.
#    Эти системы наблюдают за неблокирующими сокетами и уведомляют нас, когда с сокетом можно начинать работу. 
#    Именно они лежат в основе модели конкурентности в asyncio.
#    В этой модели имеется только один поток, исполняющий Python-код.
#    Встретив операцию ввода-вывода, интерпретатор передает ее на попечение системы
#    уведомления, входящей в состав ОС. Совершив этот акт, поток Python
#    волен исполнять другой код или открыть другие неблокирующие сокеты,
#     о которых позаботится ОС. По завершении операции система
#    «пробуждает» задачу, ожидающую результата, после чего выполняется код, следующий за этой операцией
#    Но как теперь отличить задачи, ожидающие завершения ввода-вывода,
#    от тех, которые просто выполняют Python-код и ничего не ждут?
#    Ответ дает конструкция под названием «цикл событий»(event-loop).
#    
#Event loop
#    Цикл событий – сердце любого приложения asyncio. Этот паттерн проектирования
#    встречается во многих системах и был придуман уже
#    довольно давно. Используя в браузере JavaScript для отправки асинхронного запроса, 
#    вы создаете задачу, управляемую циклом событий.
#    В GUI-приложениях Windows за кулисами используются так называемые 
#    циклы обработки сообщений; это основной механизм обработки
#    таких событий, как нажатие клавиш, он позволяет одновременно отрисовывать 
#    интерфейс и реагировать на действия пользователя.
#    По сути своей, цикл событий очень прост. Мы создаем очередь, в которой хранится список событий 
#    или сообщений, а затем входим в бесконечный цикл, где обрабатываем сообщения 
#    по мере их поступления.
#    В asyncio цикл событий управляет очередью задач, а не сообщений.
#    Задача – это обертка вокруг сопрограммы. Сопрограмма может приостановить выполнение, 
#    встретив операцию ввода-вывода, и дать циклу событий возможность выполнить другие задачи, 
#    которые не ждут завершения ввода-вывода.
#    Создавая цикл событий, мы создаем пустую очередь задач. Затем
#    добавляем в эту очередь задачи для выполнения. На каждой итерации цикла проверяется,
#    есть ли в очереди готовая задача, и если
#    да, то она выполняется, пока не встретит операцию ввода-вывода.
#    В этот момент задача приостанавливается, и мы просим операционную систему наблюдать
#    за ее сокетами. А сами тем временем переходим к следующей готовой задаче. 
#    На каждой итерации проверяется, завершилась ли какая-нибудь операция ввода-вывода; 
#    если да, то ожидавшие ее завершения задачи пробуждаются и им 
#    предоставляется возможность продолжить работу.
#Resume:
#    1. Ограниченной быстродействием процессора (счетной) называется
#    работа, потребляющая в основном ресурсы процессора, а ограниченной производительностью
#    ввода-вывода – работа, потребляющая в основном ресурсы сети или других устройств ввода-вывода.
#    Главная задача библиотеки asyncio – обеспечить конкурентность
#    задач, ограниченных производительностью ввода-вывода, однако
#    она также предлагает API для организации конкурентности счетных задач.
#    2. Процессы и потоки – основные единицы конкурентности на уровне 
#    операционной системы. Процессы можно использовать для
#    рабочих нагрузок, ограниченных как производительностью ввода-вывода, 
#    так и быстродействием процессора, а потоки в Python
#    (обычно) – только для эффективного управления задачами, ограниченными 
#    производительностью ввода-вывода, потому что GIL
#    не дает выполнять код параллельно
#    3. Мы видели, что в случае неблокирующих сокетов можно не при-останавливать
#    приложение на время ожидания данных, а попросить операционную систему 
#    уведомить нас, когда данные поступят.
#    Именно это позволяет asyncio организовать конкурентность в одном потоке.
#    4. Мы познакомились с циклом событий, лежащим в основе приложений asyncio. 
#    В бесконечном цикле событий исполняются счетные задачи, а задачи, ожидающие ввода-вывода, 
#    приостанавливаются.
#