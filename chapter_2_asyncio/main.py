# import asyncio
#
# from chapter_2_asyncio.utils.sleep import sleep_func
# import asyncio
# import time

from utils.sleep import async_timer, sleep_func

note = """Сопрограммы(корутины)
    Сопрограмму можно рассматривать как обычную функцию Python,
    наделенную сверхспособностью: приостанавливаться, встретив операцию, 
    для выполнения которой нужно заметное время. По завершении 
    такой длительной операции сопрограмму можно «пробудить»,
    после чего она продолжит выполнение. Пока приостановленная сопрограмма 
    ждет завершения операции, мы можем выполнять другой
    код. Такое выполнение другого кода во время ожидания и обеспечивает 
    конкурентность внутри приложения. Можно также одновременно выполнять несколько 
    длительных операций, что еще больше повышает производительность приложения.
    Для создания и приостановки сопрограммы нам придется использовать ключевые
    слова Python async и await. Слово async определяет сопрограмму, а слово await 
    приостанавливает ее на время выполнения длительной операции
    обычная функция исполняется и возвращает управление сразу, Однако код сопрограммы
    вообще не выполняется, а получаем мы объект сопрограммы.
    Это важный момент – сопрограммы не выполняются, если их вызвать напрямую. 
    Вместо этого возвращается объект сопрограммы,
    который будет выполнен позже. Чтобы выполнить сопрограмму, мы
    должны явно передать ее циклу событий. И как же создать цикл событий 
    и выполнить в нем нашу сопрограмму?
    В версиях Python, предшествующих 3.7, цикл событий нужно было
    создавать вручную, если его еще не было. Но затем в asyncio было добавлено несколько функций, 
    абстрагирующих управление циклом событий. 
    Одна из них – вспомогательная функция asyncio.run, которую
    можно использовать для запуска нашей сопрограммы.
    В этом случае asyncio.run делает несколько важных вещей. Во-первых, 
    она создает новое событие. Потом она выполняет код переданной нами сопрограммы 
    до конца и возвращает результат. Эта функция также подчищает все то, 
    что могло остаться после завершения сопрограммы. И в конце она останавливает 
    и закрывает цикл событий.
    Но, возможно, самое главное в asyncio.run – то, что она задумана
    как главная точка входа в созданное нами приложение asyncio. Она
    выполняет только одну сопрограмму, и эта сопрограмма должна позаботиться 
    обо всех остальных аспектах приложения. Далее мы будем
    использовать эту функцию почти во всех наших приложениях. Сопрограмма, 
    которую выполняет asyncio.run, должна создать и запустить
    все прочие сопрограммы, это позволит нам обратить себе на пользу
    конкурентную природу asyncio.
    
await
    Для приостановки выполнения служит ключевое слово await, за ним
    обычно следует обращение к сопрограмме (точнее, к объекту, допускающему 
    ожидание, который необязательно является сопрограммой;
    мы вернемся к этому вопросу ниже в этой главе)
    Использование ключевого слова await приводит к выполнению
    следующей за ним сопрограммы, а не просто к возврату объекту сопрограммы, 
    как при прямом вызове. Кроме того, выражение await
    приостанавливает объемлющую сопрограмму до того момента, как
    сопрограмма, которую мы ждем, завершится и вернет результат.
    А после этого мы получим доступ к возвращенному результату, а объемлющая 
    сопрограмма пробудится и обработает результат.
    Этот код работает так же, как обычный последовательный код. По
    существу, мы имитируем обычный стек вызовов. А теперь рассмотрим простой пример, 
    показывающий, как во время ожидания выполнить другой код, для чего введем в 
    рассмотрение фиктивную операцию засыпания.
    
asyncio.sleep()
    В предыдущих примерах не было медленных операций, мы просто
    изучили базовый синтаксис сопрограмм. Чтобы в полной мере прочувствовать 
    все преимущества и показать, как обрабатывать несколько событий одновременно, 
    нам нужны какие-то длительные операции. Но, вместо того чтобы сразу отправлять 
    недетерминированные веб-запросы или запросы к базе данных, мы смоделируем длительную 
    операцию, указав, сколько времени ждать завершения. Для этого воспользуемся функцией 
    asyncio.sleep
    Функция asyncio.sleep заставляет сопрограмму «заснуть» на заданное число секунд, 
    т.е. приостанавливает ее на заданное время. Это позволяет смоделировать, что происходит при 
    обращении к базе данных или веб-ресурсу.
    asyncio.sleep сама является сопрограммой, поэтому вызывать ее
    следует с помощью await. Вызвав ее напрямую, мы получим просто
    объект сопрограммы. Раз asyncio.sleep – сопрограмма, то, пока мы
    ее ждем, может выполняться другой код.
    
    При выполнении кода main с add_one/sleep_hello_world проходит 1 с, 
    прежде чем будут напечатаны результаты обеих функций. 
    Мы же хотели, чтобы значение
    add_one(1) было напечатано немедленно, пока hello_world_message()
    работает конкурентно. И что же не так с этим кодом? Дело в том, что
    await приостанавливает текущую сопрограмму и код внутри нее не
    выполняется, пока выражение await не вернет значение. Поскольку
    hello_world_message вернет значение только через секунду, сопрограмма main на эту
    секунду и приостанавливается. В данном случае код ведет себя как последовательный.
    И main, и hello_world приостановлены в ожидании завершения sleep_func(1). 
    А когда это случится, main возобновляется и может выполнить add_one
    Нам хотелось бы уйти от этой последовательной модели и выполнять add_one 
    конкурентно с hello_world. Для этого введем в рассмотрение концепцию задачи(tasks)
    
Конкурентное выполнение с помощью задач(Tasks)
    Ранее мы видели, что непосредственный вызов сопрограммы не передает ее циклу 
    событий для выполнения. Вместо этого мы получаем
    объект сопрограммы, который нужно затем использовать совместно
    с ключевым словом await или передать функции asyncio.run, чтобы
    получить возвращенное значение. Располагая только этими инструментами, мы можем написать 
    асинхронный код, но не можем выполнить его конкурентно. А чтобы это сделать, нужны задачи.
    Задача – это обертка вокруг сопрограммы, которая планирует выполнение последней в цикле 
    событий как можно раньше. И планирование, и выполнение происходят в неблокирующем режиме, т. е.,
    создав задачу, мы можем сразу приступить к выполнению другого
    кода, пока эта задача работает в фоне. Сравните с ключевым словом
    await, которое блокирует выполнение, т. е. мы приостанавливаем
    всю сопрограмму на время, пока выражение await не вернет управление.
    Способность создавать задачи и планировать их для немедленного
    выполнения в цикле событий означает, что несколько задач может работать приблизительно в одно и то же время. 
    Пока одна задача выполняет длительную операцию, другие могут работать конкурентно. 
    Для иллюстрации создадим две задачи и попробуем выполнить их одновременно.
    Для создания задачи служит функция asyncio.create_task. Ей передается подлежащая выполнению сопрограмма, 
    а в ответ она немедленно возвращает объект задачи. Этот объект можно включить в выражение await, 
    которое извлечет возвращенное значение по завершении задачи
    
Конкурентное выполнение нескольких задач
    Коль скоро задачи создаются мгновенно и планируются для выполнения как можно раньше, 
    мы получаем возможность конкурентно выполнять несколько длительных задач. 
    Для этого нужно последовательно запустить несколько задач в одной долго работающей сопрограмме.
    Ниже мы запустили три задачи, каждой из которых для завершения
    нужно 5 с. Каждое обращение к create_task возвращает управление
    немедленно, поэтому до предложения await task_1 мы доходим сразу же. 
    Ранее мы отмечали, что выполнение задач планируется «как можно раньше». На практике это означает, 
    что в точке, где встречается первое после создания задачи предложение await, все
    ожидающие задачи начинают выполняться, так как await запускает
    очередную итерацию цикла событий
    Поскольку первым мы встречаем предложение await task_1, 
    все три задачи начинают выполняться и засыпают одновременно. 
    Значит, программа завершится примерно через 5 с.
    Эта конкурентность показана на рис. 2.3 – обратите внимание, что все
    три задачи исполняют свои сопрограммы sleep в одно и то же время.
    Конкурентное выполнение таких длительных операций – как раз
    та область, где asyncio блистает и резко улучшает производительность
    приложения, но на этом преимущества не заканчиваются. Приложение
    в листинге 2.9 активно било баклуши, в течение трех секунд ожидая истечения времени
    задержки. Но пока один код ожидает, можно было бы выполнить другой. 
    Допустим, мы хотим один раз в секунду печатать
    сообщения о состоянии, пока какие-то длительные задачи работают
    Потенциальная проблема заключается в том, что задача может работать неопределенно долго. 
    Быть может, нам захочется остановить задачу, если она никак не кончается сама. 
    Такая возможность поддерживается и называется снятием.
    
Снятие задач и задание тайм-аутов
    Сетевые подключения ненадежны. Установленное пользователем
    подключение может быть разорвано из-за медленной сети, или веб-сервер может «упасть» и 
    оставить существующие запросы в подвешенном состоянии. Поэтому, отправляя запросы, 
    мы должны внимательно следить за ними, чтобы не ждать слишком долго. Иначе
    приложение может зависнуть, ожидая результата, который никогда
    не придет. Наш пользователь останется недоволен – маловероятно,
    что он захочет вечно ждать ответа на свой запрос. Кроме того, иногда
    имеет смысл предоставить пользователю выбор, если задача работает слишком долго. 
    Пользователь может согласиться с тем, что его запрос требует много времени, или остановить задачу, 
    запущенную по ошибке.
    В рассмотренных выше примерах если бы задачи работали вечно,
    то мы бы застряли в предложении await без всякой обратной связи.
    И остановить бы программу не смогли, даже если бы захотели. В библиотеке asyncio предусмотрены 
    обе ситуации – мы можем снять задачу или задать тайм-аут.
    
Снятие задач
    Снять задачу просто. У каждого объекта задачи есть метод cancel, который можно вызвать, 
    если требуется остановить задачу. В результате снятия задача возбудит исключение 
    CancelledError, когда мы ждем ее с помощью await. Это исключения можно обработать, 
    как того требует ситуация.
    ля иллюстрации предположим, что мы запустили задачу, которая
    не должна работать дольше 5 с. Если за это время задача не завершилась, 
    то мы хотим ее снять, сообщив пользователю, что задача работает 
    слишком долго и будет остановлена. Мы также хотим каждую
    секунду печатать сообщение о состоянии, чтобы держать пользователя 
    в курсе, а не оставлять в неведении на протяжении нескольких секунд.
    Важно отметить, что исключение CancelledError может быть возбуждено 
    только внутри предложения await. То есть, если вызвать метод cancel, 
    когда задача исполняет Python-код, этот код будет продолжать работать, 
    пока не встретится следующее предложение await
    (если встретится), и только тогда будет возбуждено исключение CancelledError. 
    Вызов cancel не прерывает задачу, делающую свое дело;
    он снимает ее, только если она уже находится в точке ожидания или
    когда дойдет до следующей такой точки.
    
Задание тайм-аута и снятие с помощью wait_for
    Проверять состояние каждую секунду или с другим интервалом, как
    в предыдущем примере, – не самый простой способ реализации тайм-аута.
    В идеале хотелось бы иметь вспомогательную функцию, которая
    позволяла бы задать тайм-аут и снять задачу по его истечении.
    В asyncio есть такая возможность в виде функции asyncio.wait_for.
    Она принимает объект сопрограммы или задачи и тайм-аут в секундах и возвращает сопрограмму, 
    к которой можно применить await. Если задача не завершилась в отведенное время,
    то возбуждается исключение TimeoutError и задача автоматически снимается
    Для иллюстрации работы wait_for мы рассмотрим случай, когда за-
    даче требуется две секунды, но мы даем ей только одну. Мы перехва-
    тываем исключение TimeoutError и смотрим, была ли задача снята.
    Автоматическое снятие задачи, работающей дольше, чем ожида-
    ется, обычно является разумной практикой. В противном случае со-
    программа могла бы ждать неопределенно долго, занимая ресурсы,
    которые никогда не будут освобождены. Но в некоторых случаях же-
    лательно дать сопрограмме поработать. Например, по прошествии
    некоторого времени мы можем проинформировать пользователя
    о том, что работа занимает дольше, чем ожидалось, но не снимать ее,
    когда тайм-аут истечет.
    Для этого обернем нашу задачу функцией asyncio.shield. Эта
    функция предотвращает снятие сопрограммы, снабжая ее «щитом»,
    позволяющим игнорировать запросы на снятие.
    Снятие и защита от снятия – довольно хитрые вещи, у которых есть
    несколько достойных внимания сценариев применения. Мы позна-
    комились с основами, но по мере усложнения примеров более глубо-
    ко изучим, как работает механизм снятия.
    Мы рассмотрели основы задач и сопрограмм. Эти понятия пере-
    плетаются. В следующем разделе мы поговорим о том, как они связа-
    ны между собой, и увидим, как устроена библиотека asyncio.
    
Задачи, сопрограммы, будущие объекты и объекты, допускающие ожидание
    И сопрограммы, и задачи можно использовать в выражениях await.
    Так что же между ними общего? Чтобы ответить на этот вопрос, нуж-
    но знать о типах future и awaitable. На практике будущие объекты
    (future) бывают нужны редко, но понимать их необходимо, если мы
    хотим уяснить, как работает asyncio. Далее в книге мы будем специ-
    ально отмечать API, возвращающие будущие объекты.
    Объект future в Python содержит одно значение, которое мы ожидаем
    получить в будущем, но пока еще, возможно, не получили. Обычно
    в момент создания future не обертывает никакого значения, потому
    что его еще не существует. Объект в таком состоянии называется не-
    полным, неразрешенным или просто неготовым. И только получив
    результат, мы можем установить значение объекта future, в резуль-
    тате чего он становится полным и из него можно извлечь результат.
    Для создания объекта future нужно вызвать его конструктор. В этот
    момент во future нет никакого результата, поэтому вызов метода
    done возвращает False. Затем мы устанавливаем значение future ме-
    тодом set_result, который помечает его как готовый. Если бы вместо
    этого мы хотели записать во future исключение, то вызвали бы метод
    set_exception.
    Мы не вызываем метод result, прежде чем ре-
    зультат установлен, потому что тогда он возбудил бы исключе-
    ние InvalidState.
    Будущие объекты также можно использовать в выражениях await.
    Это означает «я посплю, пока в будущем объекте не будет установле-
    но значение, с которым я могу работать, а когда оно появится, разбу-
    ди меня и дай возможность его обработать».
    В asyncio редко приходится иметь дело с будущими объектами. Тем
    не менее встречаются API, возвращающие будущие объекты, а иногда
    возникает необходимость писать код обратных вызовов, что требует
    будущих объектов. Кроме того, возможно, вам доведется читать или
    отлаживать код каких-то API asyncio самостоятельно. Реализация та-
    ких API опирается на будущие объекты, так что неплохо бы хотя бы
    в общих чертах понимать, как они работают.
    
Связь между будущими объектами, задачами и сопрограммами
    Между задачами и будущими объектами существует тесная связь. На
    самом деле task напрямую наследует future. Можно считать, что объ-
    ект future представляет значение, которое появится только в буду-
    щем. А task является комбинацией сопрограммы и future. Создавая
    задачу, мы создаем пустой объект future и запускаем сопрограмму.
    А когда сопрограмма завершится с результатом или вследствие ис-
    ключения, мы записываем этот результат или объект-исключение во
    future.
    А существует ли аналогичная связь между задачами и сопрограм-
    мами? Ведь все эти типы можно использовать в выражениях await.
    Связующим звеном между ними является абстрактный базовый
    класс Awaitable. В нем определен единственный абстрактный метод
    __await__. Мы не будем вдаваться в детали того, как создавать соб-
    ственные объекты, допускающие ожидание, а просто скажем, что лю-
    бой объект, который реализует метод __await__, можно использовать
    в выражении await. Сопрограммы, как и будущие объекты, наследуют
    Awaitable напрямую.
    Awaitable -> Coroutine
              -> Future -> Task
    Далее будем называть объекты, которые можно использовать в вы-
    ражениях await, объектами, допускающими ожидание (awaitable). Этот
    термин часто встречается в документации по asyncio, поскольку мно-
    гие методы API готовы принимать и сопрограммы, и задачи, и буду-
    щие объекты.
    Итак, с основами сопрограмм, задач и будущих объектов мы разо-
    брались. А как оценить их производительность? До сих пор мы только
    теоретизировали на тему времени их работы. Чтобы сделать рассуж-
    дения более строгими, добавим средства измерения времени.
    
Измерение времени выполнения сопрограммы с помощью декораторов
    До сих пор мы лишь приблизительно говорили о том, сколько време-
    ни работают наши приложения, не измеряя его явно. Чтобы постро-
    ить настоящий профиль, нужно написать код хронометража.
    Однако если предложений await и задач много, то это быстро надо-
    едает. Хорошо бы придумать допускающий повторное использование
    способ замерять время работы любой сопрограммы. Это можно сде-
    лать с помощью декоратора, который будет выполнять предложение
    await за нас
    
Ловушки сопрограмм и задач
    Увидев, какой выигрыш может дать конкурентное выполнение дли-
    тельных задач, мы можем поддаться искушению использовать со-
    программы и задачи всюду и везде. Но просто снабдить функции
    ключевым словом async и обернуть их задачами может оказаться не-
    достаточно для повышения производительности. А в некоторых слу-
    чаях производительность может даже упасть.
    Есть две основные ошибки на пути преобразования приложения
    в асинхронное. Первая – попытка выполнить счетный код в задачах
    или сопрограммах, не прибегая к многопроцессности, вторая – ис-
    пользовать блокирующие API ввода-вывода, пренебрегая многопо-
    точностью
    
Выполнение счетного кода(CPU-bound task)
    В программе могут быть функции, выполняющие длительные вы-
    числения, например обход большого словаря или математические
    расчеты. Если есть возможность выполнять эти функции конку-
    рентно, то может возникнуть идея поместить их в отдельные за-
    дачи. В принципе, ничего плохого в этом нет, но нужно помнить,
    что модель конкурентности в asyncio однопоточная. Это значит, что
    действуют все ограничения одного потока и глобальной блокировки
    интерпретатора.
    Кажется, что эта(нижняя) программа должна работать столько же, сколько
    программа в листинге 2.18. Разве task_three не будет выполняться
    конкурентно со счетными задачами? Нет, не будет, потому что мы
    сначала создали две счетные задачи и тем самым не даем циклу со-
    бытий выполнить что-то еще. Следовательно, время работы прило-
    жения будет равно сумме времен работы задач cpu_bound_work плюс
    4 с, которые займет задача task_three.
    Если требуется выполнить счетную работу и все-таки использовать
    async / await, то это можно сделать. Но придется воспользоваться
    многопроцессностью и попросить asyncio выполнять наши задачи
    в пуле процессов. Как это сделать, мы узнаем в главе 6.
    
Выполнение блокирующих API
    Может возникнуть соблазн использовать существующие библиотеки
    ввода-вывода, обернув их сопрограммами. Однако при этом возник-
    нут те же проблемы, что для счетных операций. Эти API будут блокиро-
    вать главный поток. Поэтому, попытавшись выполнить блокирующий
    вызов API в сопрограмме, мы заблокируем сам поток цикла событий,
    а значит, воспрепятствуем выполнению всех остальных сопрограмм
    и задач. Примерами блокирующих API является библиотека requests
    или функция time.sleep. Вообще, любая функция, которая выполняет
    ввод-вывод, не являясь сопрограммой, или занимает процессор дли-
    тельными операциями, может считаться блокирующей.
    Большинство API, с которыми мы обычно работаем, в настоящее
    время являются блокирующими и без доработок работать с asyncio не
    будут. Нужно использовать библиотеку, которая поддерживает сопро-
    граммы и неблокирующие сокеты. А это значит, что если используе-
    мая вами библиотека не возвращает сопрограммы и вы не употре-
    бляете await в собственных сопрограммах, то, вероятно, совершаете
    блокирующий вызов.
    Если вы все-таки хотите использовать библиотеку requests, то син-
    таксис async применить можно, но нужно явно попросить asyncio за-
    действовать многопоточность с помощью исполнителя пула потоков.
    Как это делается, узнаем в главе 7.
    Мы рассказали, на что обращать внимание при работе с asyncio,
    и написали несколько простых приложений. До сих пор мы не соз-
    давали и не конфигурировали цикл событий самостоятельно, а по-
    лагались на уже готовые методы. В следующем разделе научимся
    создавать цикл событий, что позволит нам получить доступ к низ-
    коуровневой функциональности asyncio и конфигурационным свой-
    ствам цикла событий.
    
Ручное управление циклом событий
    До сих пор мы пользовались вспомогательной функцией asyncio.run,
    которая за кулисами создавала цикл событий и запускала приложение.
    В силу своей простоты это предпочтительный метод создания цикла
    событий. Но бывает, что функциональность, предлагаемая asyncio.run
    нас не устраивает. Например, что, если мы хотим реализовать
    специальную логику остановки задач, например дать оставшимся за-
    дачам завершиться, а не останавливать их, как делает asyncio.run
    Кроме того, могут понадобиться методы самого цикла событий. Как
    правило, они низкоуровневые, так что злоупотреблять ими не стоит.
    Однако если нужно сделать что-то нестандартное, например работать
    с сокетами напрямую или запланировать задачу на конкретный мо-
    мент в будущем, то доступ к циклу событий необходим. Мы, конечно,
    не хотим и не должны увлекаться ручным управлением циклом со-
    бытий, но временами от этого никуда не деться.
    
Создание цикла событий вручную
    Мы можем создать цикл событий, воспользовавшись методом asyncio.new_event_loop. 
    Он возвращает экземпляр цикла событий, кото-
    рый дает доступ ко всем низкоуровневым методам, в частности мето-
    ду run_until_complete, который принимает сопрограмму и исполняет
    ее до завершения. Закончив работу с циклом событий, мы должны за-
    крыть его, чтобы освободить занятые ресурсы. Обычно это делается
    в блоке finally, чтобы цикл был закрыт даже в случае исключения
    Это похоже на то, что происходит при вызове asyncio.run, с той
    разницей, что оставшиеся задачи не отменяются. Если нам нужна
    специальная логика очистки, то ее следует реализовать в предложе-
    нии finally.
    
Получение доступа к циклу событий
    Иногда бывает необходим доступ к текущему циклу событий. Библио-
    тека asyncio предоставляет для этой цели функцию asyncio.get_run-
    ning_loop. В качестве примера рассмотрим метод call_soon, который
    планирует выполнение функции на следующей итерации цикла со-
    бытий.
    Здесь сопрограмма main получает цикл событий от функции asyncio.get_running_loop, 
    и вызывает его метод call_later, который при-
    нимает функцию и выполняет ее на следующей итерации цикла. Су-
    ществует еще функция asyncio.get_event_loop, также позволяющая
    получить доступ к циклу событий. Эта функция может создать новый
    цикл событий, если его еще не существует в момент вызова, что ведет
    к странному поведению. Рекомендуется использовать get_running_loop, 
    поскольку она возбуждает исключение, если цикл событий не
    запущен, что позволяет избежать сюрпризов.
    Хотя явно использовать цикл событий в приложениях слишком
    часто не стоит, бывает, что нужно настроить его параметры или вос-
    пользоваться низкоуровневыми функциями. В следующем разде-
    ле мы рассмотрим пример перевода цикла событий в отладочный
    режим

Отладочный режим
    Использование asyncio.run
        Функция asyncio.run, которой мы пользовались для выполнения со-
        программ, имеет именованный параметр debug. По умолчанию он
        равен False, но если присвоить ему значение True, то активируется
        отладочный режим:
        asyncio.run(coroutine(), debug=True)
    Использование аргументов командной строки
        Включить отладочный режим можно, передав аргумент -X dev в ко -
        мандной строке, запускающей Python-приложение:
        python3 -X dev program.py
    Использование переменных окружения
        Включить отладочный режим можно также, присвоив значение 1 пе-
        ременной окружения PYTHONASYNCIODEBUG=1
    В отладочном режиме мы будем видеть информационные сообще-
    ния, если сопрограмма работает слишком долго. Чтобы проверить
    это, попробуем запустить следующий счетный код в задаче и посмо-
    трим, будет ли напечатано предупреждение
    Это может быть полезно для отладки ошибок, связанных со слу-
    чайным выполнением блокирующего вызова. По умолчанию пара-
    метры заданы так, что предупреждение выдается, если сопрограмма
    работает дольше 100 мс, но, возможно, для вас это слишком мало или
    слишком много. Чтобы изменить значение, нужно получить объект
    цикла событий и задать в нем параметр slow_callback_duration
    loop = asyncio.get_event_loop()
    loop.slow_callback_duration = .250

Resume: 
    1. Мы научились создавать сопрограммы с помощью ключевого слова
    async. Сопрограмма может приостанавливать себя, встретив бло-
    кирующую операцию. Это дает возможность поработать другим
    сопрограммам. После завершения операции, на которой сопро-
    грамма приостановилась, она пробуждается и продолжает работу
    с прерванного места.
    
    2. Мы узнали, что вызову сопрограммы должно предшествовать клю-
    чевое слово await, означающее, что нужно дождаться возврата зна-
    чения. При этом сопрограмма, внутри которой встретилось слово
    await, приостанавливается в ожидании результата. В это время мо-
    гут работать другие сопрограммы.
    
    3. Мы узнали, как использовать функцию asyncio.run для выполне-
    ния одной сопрограммы, являющейся точкой входа в приложение.
    
    4. Мы научились использовать задачи для конкурентного выполне-
    ния нескольких длительных операций. Задачи – это обертки вокруг
    сопрограмм, которые исполняются в цикле событий. Созданная за-
    дача планируется для выполнения как можно раньше.
    
    5. Мы узнали, как снимать задачу, когда нужно остановить ее, и как
    задать тайм-аут, чтобы задача не работала бесконечно долго. После
    снятия задачи возбуждается исключение CancelledError, когда мы
    ожидаем результат. Если имеются ограничения на время работы
    задачи, то можно задать тайм-аут в методе asycio.wait_for.
    
    6. Мы научились избегать типичных ошибок, которые допускают на-
    чинающие изучать asyncio. Первая – выполнение счетного кода
    в сопрограммах. Счетный код блокирует цикл событий и не дает
    выполняться другим сопрограммам, потому что модель конкурент-
    ности однопоточная. Вторая – блокирующий ввод-вывод, потому
    что обычные библиотеки нельзя использовать совместно с asyncio,
    а нужно работать с заточенными под asyncio и возвращающими со-
    программы. Если внутри вашей сопрограммы не встречается await,
    это должно вызвать подозрения. Тем не менее существуют спосо-
    бы исполнять счетный код и блокирующий ввод-вывод совместно
    с asyncio, мы рассмотрим их в главах 6 и 7.
    
    7.Мы узнали об отладочном режиме. Он помогает диагностировать
    типичные проблемы в коде на основе asyncio, например выполне-
    ние счетного кода в сопрограмме
"""

with open("notes.txt", "w", encoding="utf-8") as file:
    file.write("#" + "\n#".join(note.split("\n")))

# async def coroutine_add_one(number: int) -> int:
#     return number + 1
#
#
# def add_one(number: int) -> int:
#     return number + 1
#
#
# function_result = add_one(1)
# coroutine_result = asyncio.run(coroutine_add_one(1))
# print(f'Результат функции равен {function_result}, а его тип равен{type(function_result)}')
# print(f'Результат сопрограммы равен {coroutine_result}, а его тип равен {type(coroutine_result)}')


# async def add_one(number: int) -> int:
#     return number + 1

# async def main() -> None:
#     one_plus_one = await add_one(1)  # Приостановиться и ждать результата add_one(1)
#     two_plus_one = await add_one(2)  # Приостановиться и ждать результата add_one(2)
#     print(one_plus_one)
#     print(two_plus_one)
#
#
# asyncio.run(main())


# async def sleep_hello_world(sec: int) -> str:
#     await sleep_func(sec)
#     return "hello world"


# async def main() -> None:
#     msg = await sleep_hello_world(1)  # Приостановить main до завершения sleep_hello_world()
#     num = await add_one(1)  # Приостановить main до завершения add_one(1)
#     print(num)
#     print(msg)


# async def main():
#     sleep_for_three = asyncio.create_task(sleep_func(3))
#     print(type(sleep_for_three))
#     result = await sleep_for_three
#     print(result)


# async def hello_every_second():
#     for i in range(5):
#         await asyncio.sleep(1)
#         print("пока я жду, исполняется другой код!")


# async def main():
#     task_1 = asyncio.create_task(sleep_func(5))
#     task_2 = asyncio.create_task(sleep_func(5))
#     await hello_every_second()
#     await task_1
#     await task_2


# async def main():
#     long_task = asyncio.create_task(sleep_func(10))
#     seconds_elapsed = 0
#     while not long_task.done():
#         print('Задача не закончилась, следующая проверка через секунду.')
#         await asyncio.sleep(1)
#         seconds_elapsed += 1
#         if seconds_elapsed == 5:
#             long_task.cancel()
#     try:
#         await long_task
#     except CancelledError:
#         print('Наша задача была снята')


# async def main():
#     delay_task = asyncio.create_task(sleep_func(2))
#     try:
#         result = await asyncio.wait_for(delay_task, timeout=1)
#         print(result)
#     except asyncio.exceptions.TimeoutError:
#         print('Тайм-аут!')
#         print(f'Задача была снята? {delay_task.cancelled()}')


# async def main():
#     task = asyncio.create_task(sleep_func(5))
#     try:
#         result = await asyncio.wait_for(asyncio.shield(task), timeout=5)
#         print(result)
#     except TimeoutError:
#         print("Задача заняла более 5 с, скоро она закончится!")
#         result = await task
#         print(result)


# asyncio.run(main())


# from asyncio import Future

# my_future = Future()
# print(f'my_future готов? {my_future.done()}')
# my_future.set_result(42)
# print(f'my_future готов? {my_future.done()}')
# print(f'Какой результат хранится в my_future? {my_future.result()}')


# from asyncio import Future
# import asyncio
#
#
# def make_request() -> Future:
#     future = Future()
#     asyncio.create_task(set_future_value(future))  # Создать задачу, которая асинхронно установит значение future
#     return future
#
#
# async def set_future_value(future) -> None:
#     await asyncio.sleep(1)  # Ждать 1 с, прежде чем установить значение
#
#     future.set_result(42)
#
#
# async def main():
#     future = make_request()
#
#     print(f'Будущий объект готов? {future.done()}')
#     value = await future  # Приостановить main, пока значение future не установлено
#     print(f'Будущий объект готов? {future.done()}')
#     print(value)
#
#
# asyncio.run(main())


# async def main():
#     start = time.time()
#     await asyncio.sleep(1)
#     end = time.time()
#     print(f'Сон занял {end - start} с.')


# import asyncio


# @async_timer()
# async def delay(delay_seconds: int) -> int:
#     print(f'засыпаю на {delay_seconds} с')
#     await asyncio.sleep(delay_seconds)
#     print(f'сон в течение {delay_seconds} с закончился')
#     return delay_seconds
#
#
# @async_timer()
# async def main():
#     task_one = asyncio.create_task(delay(2))
#     task_two = asyncio.create_task(delay(3))
#     await task_one
#     await task_two


# import asyncio


# @async_timer()
# async def cpu_bound_work() -> int:
#     counter = 0
#     for i in range(100000000):
#         counter += 1
#     return counter
#
#
# @async_timer()
# async def main():
#     task_one = asyncio.create_task(cpu_bound_work())
#     task_two = asyncio.create_task(cpu_bound_work())
#     task_three = asyncio.create_task(sleep_func(5))
#     await task_one
#     await task_two
#     await task_three
# asyncio.run(main())


# import asyncio
#
#
# async def main():
#     await asyncio.sleep(1)
#
#
# loop = asyncio.new_event_loop()
# try:
#     loop.run_until_complete(main())
# finally:
#     loop.close()


import asyncio


def call_later():
    print("Меня вызовут в ближайшем будущем!")


async def main():
    loop = asyncio.get_running_loop()
    loop.call_soon(call_later)
    await sleep_func(1)

asyncio.run(main(), debug=True)
